#!/usr/bin/perl -w

++$|;
use strict;
use Getopt::Long;
use Mail::IMAPClient;
use Digest::MD5  qw(md5_base64);
#use Digest::HMAC_MD5;

eval { require 'usr/include/sysexits.ph' };


my(
        $rcs, $debug, $debugimap, $error,
	$host1, $host2, $port1, $port2,
	$user1, $user2, $password1, $password2, $passfile1, $passfile2,
	$owner,
        @folder, $include, $exclude, $prefix2, $regextrans2, @regexmess,
        $sep1, $sep2,
	$syncinternaldates, $syncacls,
	$maxsize, $minage,
        $skipheader, $skipsize, $foldersizes,
	$delete, $expunge, $dry, 
        $authmd5,
        $subscribed, $subscribe,
	$version, $VERSION, $help, 
        $justconnect, $justfolders,
        $fast,
	$skipunread,
	$prefixowner,
	$namespace,
	$silent,
        $mess_size_total_trans,
        $mess_size_total_skipped,
        $mess_size_total_error,
        $mess_trans, $mess_skipped,
        $timeout,   # whr (ESS/PRW)
	$timestart, $timeend, $timediff,
        $timesize, $timebefore,

);

use vars qw ($opt_G); # missing code for this will be option.


$rcs = ' $Id: imapsync,v 1.118 2005/01/17 14:45:25 gilles Exp $ ';
$rcs =~ m/,v (\d+\.\d+)/;
$VERSION = ($1) ? $1 : "UNKNOWN";

my $VERSION_IMAPClient = $Mail::IMAPClient::VERSION;

my $md5_supported = 0;
$md5_supported = md5_supported();

$mess_size_total_trans   = 0;
$mess_size_total_skipped = 0;
$mess_size_total_error   = 0;
$mess_trans = $mess_skipped = 0;

sub md5_supported {
	
	
	# before 2.2.6 no md5 native
	# I know this is ugly, I should write a sort function
	if ($VERSION_IMAPClient =~ m/(\d+)\.(\d+)\.(\d+)/) {
		$debug and print "VERSION_IMAPClient $1 $2 $3\n";
		my($major,$minor,$sub) = ($1, $2, $3);
		return(1) if($major >=3);
		return(0) if($major <=1);
		return(1) if($minor >=3);
		return(0) if($minor <=1);
		return(1) if($sub >=6);
		return(0) if($sub <=5);
	}else{
		return 0; # don't match regex => bad
	}
}

$error=0;

my $banner = join("", 
		  '$RCSfile: imapsync,v $ ',
		  '$Revision: 1.118 $ ',
		  '$Date: 2005/01/17 14:45:25 $ ',
		  "\n",
		  "Mail::IMAPClient version used here is ",
		  $VERSION_IMAPClient, " auth md5 : $md5_supported",
		  "\n"
		 );

unless(defined(&_SYSEXITS_H)) {
	# 64 on my linux box.
	eval 'sub EX_USAGE () {64;}' unless defined(&EX_USAGE);
}

get_options();
print $banner unless($silent);

sub missing_option {
	my ($option) = @_;
	die "$option option must be used, run $0 --help for help\n";
}

$host1 || missing_option("--host1") ;
$port1 = (defined($port1)) ? $port1 : 143;
$user1 || missing_option("--user1");
$password1 || $passfile1 || missing_option("--passfile1 or --password1");
$password1 = (defined($passfile1)) ? firstline ($passfile1) : $password1;
$owner || missing_option("--owner");
$host2 || missing_option("--host2") ;
$port2 = (defined($port2)) ? $port2 : 143;
$user2 || missing_option("--user2");
$password2 || $passfile2 || missing_option("--passfile2 or --password2");
$password2 = (defined($passfile2)) ? firstline ($passfile2) : $password2;

$authmd5 = (defined($authmd5)) ? $authmd5 : 1;

$syncacls = (defined($syncacls)) ? $syncacls : 1;
$foldersizes = (defined($foldersizes)) ? $foldersizes : 1;

print "From imap server [$host1] port [$port1] user [$user1]\n";
print "To   imap server [$host2] port [$port2] user [$user2]\n";

my $from = ();
my $to = ();

my $authmech = "CRAM-MD5";

unless ($md5_supported) {
		print "Auth $authmech not supported by IMAPClient $VERSION_IMAPClient\n" unless($silent);
	}else{
		print "Auth $authmech supported by IMAPClient $VERSION_IMAPClient\n" unless($silent);	
	}

$timestart = time();
$timebefore = $timestart;

$debugimap and print "From connection\n";
$from = login_imap($host1, $port1, $user1, $password1, $debugimap, $timeout);

$debugimap and print "To  connection\n";
$to = login_imap($host2, $port2, $user2, $password2, $debugimap, $timeout);

sub login_imap {
	my($host, $port, $user, $password, 
	   $debugimap, $timeout, $authmech) = @_;
	my $imap = Mail::IMAPClient->new();
	$imap->Server($host);
	$imap->Port($port);
	$imap->Fast_io(1);
	$imap->Buffer(65536);
	$imap->Uid(1);
	$imap->Peek(1);
	$imap->Debug($debugimap);
	$imap->connect()
	  or die "Can not open imap connection on [$host] with user [$user] : $@\n";
    if ($timeout)    # whr (ESS/PRW)
    {
        $imap->Timeout($timeout);
        print "Setting imap timeout to $timeout\n" unless($silent);
    }

	$imap->User($user);
	$imap->Password($password);
	md5auth($imap);
	$imap->login() or die "Error login : [$host] with user [$user] : $@";
	return($imap);
}


sub md5auth() {
	my ($imap) = @_;
	unless ($md5_supported) {
		return;
	}
	unless ($authmd5) {
		print "$authmech not wanted by you\n" unless($silent);
		return;
	}
	if ($imap->has_capability($authmech) 
	    or $imap->has_capability("AUTH=$authmech")) {
		print "Server [", $imap->Server, 
		  "] has capability $authmech\n" unless($silent);
	}else{
		print "Server [", $imap->Server, 
		  "] has NOT capability $authmech\n" unless($silent);
		return;
	}
	#print "EE", $imap->Authmechanism(), "\n";
	if ($imap->Authmechanism($authmech)) {
		print "Using $authmech authentification\n" unless($silent);
	}else{
		$imap->Authmechanism(undef);
		print "Can NOT use $authmech authentification, using plain\n" unless($silent);
	}
	return;
}


print "From software : ", ($from->Report())[0] unless($silent);
print "To   software : ", ($to->Report())[0] unless($silent);

print "From capability : ", join(" ", $from->capability()), "\n" unless($silent); 
print "To   capability : ", join(" ", $to->capability()), "\n" unless($silent);

die unless $from->IsAuthenticated();
die unless   $to->IsAuthenticated();

my (@f_folders, @t_folders, %fs_folders);

# Make a hash of subscribed folders in source server.
map { $fs_folders{$_}=1 } $from->subscribed();




if (scalar(@folder)) {
	# folders given by option --folder
	@f_folders = @folder;
}elsif ($subscribed) {
	# option --subscribed
	@f_folders = sort keys (%fs_folders);
}else {
	# no option, all folders
	@f_folders = sort $from->folders();
	# consider (optional) includes and excludes
	if ($include) {
		@f_folders = grep  /$include/,@f_folders;
		print "Only including folders matching pattern '$include'\n" unless($silent);
	}
	if ($exclude) {
		@f_folders = grep !/$exclude/,@f_folders;
		print "Excluding folders matching pattern '$exclude'\n" unless($silent);
	}
}

@t_folders = sort @{$to->folders()};

my($f_sep,$t_sep); 
# what are the private folders separators for each server ?


$debug and print "Getting separators\n";
$f_sep = get_separator($from, $sep1, "--sep1");
$t_sep = get_separator($to, $sep2, "--sep2");

sub get_separator {
	my($imap, $sep_in, $sep_opt) = @_;
	my($sep_out);
	
	
	if ($sep_in) {
		print "Using [$sep_in] given by $sep_opt\n" unless($silent);
		$sep_out = $sep_in;
		return($sep_out);
	}
	$debug and print "Calling namespace capability\n";
	if ($imap->has_capability("namespace")) {
		$sep_out = $imap->separator();
		return($sep_out);
	}else{
		print 
		  "No NAMESPACE capability in imap server ", 
		    $imap->Server(),"\n",
		      "Give the separator caracter with the $sep_opt option\n";
		exit(1);
	}
}


print "From separator : [$f_sep]\n" unless($silent);
print "To   separator : [$t_sep]\n" unless($silent);

if ($foldersizes) {
	my $tot = 0;
	my $tmess = 0;
	print "++++ Calculating sizes ++++\n" unless($silent);
	foreach my $f_fold (@f_folders)     {
		my $stot = 0;
		my $smess = 0;
		printf("From Folder %-25s", "[$f_fold]") unless($silent);
		unless ($from->select($f_fold)) {
			warn 
			  "From Folder $f_fold : Could not select ",
			    $from->LastError,  "\n";
			$error++;
			next;
		}
		if ($minage) {
			# The pb is fetch_hash() can only be applied on ALL messages
		
			my @f_msgs = $from->before(time - 86400 * $minage);
			my $smess = scalar(@f_msgs);
			foreach my $m (@f_msgs) {
				my $s = $from->size($m)
				  or warn "Could not find size of message $m: $@\n";
				$stot += $s;
			}
		}else{
			my $hashref = {};
			$smess = $from->message_count();
			unless ($smess == 0) {
				$from->fetch_hash("RFC822.SIZE",$hashref);
				#print map {$hashref->{$_}->{"RFC822.SIZE"}, " "} keys %$hashref;
				map {$stot += $hashref->{$_}->{"RFC822.SIZE"}} keys %$hashref;
			}
		}
		printf(" Size: %9s", $stot) unless($silent);
		printf(" Messages: %5s\n", $smess) unless($silent);
		$tot += $stot;
		$tmess += $smess;
	}
	print "Total size: $tot\n" unless($silent);
	print "Total messages: $tmess\n" unless($silent);
	print "Time : ", timenext(), " s\n" unless($silent);
	
}

sub timenext {
	my ($timenow, $timerel);
	# $timebefore is global, beurk !
	$timenow    = time;
	$timerel    = $timenow - $timebefore;
	$timebefore = $timenow;
	return($timerel);
}

exit if ($justconnect);

# needed for setting flags
my $tohasuidplus = $to->has_capability("UIDPLUS");



print 
  "From folders : ", map("[$_] ",@f_folders),"\n",
  "To   folders : ", map("[$_] ",@t_folders),"\n" unless($silent);

print 
  "From subscribed folders : ", map("[$_] ", sort keys(%fs_folders)), "\n" unless($silent);

sub separator_invert {
	# The separator we hope we'll never encounter
	my $o_sep="\000";

	my($f_fold, $f_sep, $t_sep) = @_;

	my $t_fold = $f_fold;
	$t_fold =~ s@\Q$t_sep@$o_sep@g;
	$t_fold =~ s@\Q$f_sep@$t_sep@g;
	$t_fold =~ s@\Q$o_sep@$f_sep@g;
	return($t_fold);
}

if ($namespace) {
	$to->create($namespace);
}

if ($prefixowner)
{
	my $userroot;

	if($namespace) {
		$userroot = $namespace . $t_sep;
	}
	$userroot = $userroot . $owner;

	$to->create($userroot);
}

FOLDER: foreach my $f_fold (@f_folders) {
	my $mess_count = 0;

	my $t_fold;
	print "From Folder [$f_fold]\n" unless($silent);
	
	$t_fold = separator_invert($f_fold,$f_sep, $t_sep);

	my $mailroot;

	# Prefix folders with the owner name
	$t_fold = $owner . $t_sep . $t_fold if($prefixowner);

	# Add the namespace
	$t_fold = $namespace . $t_sep . $t_fold if($namespace);

	# Adding the prefix supplied by the --prefix2 option
	$t_fold = $prefix2 . $t_fold if ($prefix2);

	# Transforming the folder name by the --regextrans2 option
	if ($regextrans2) {
		$debug and print "eval \$t_fold =~ $regextrans2\n";
		eval("\$t_fold =~ $regextrans2");
	}

	print "To   Folder [$t_fold]\n" unless($silent);

	unless ($from->select($f_fold)) {
		warn 
		"From Folder $f_fold : Could not select ",
		$from->LastError,  "\n";
		$error++;
		next FOLDER;
	}

	unless ($to->exists($t_fold) or $to->select($t_fold)) { 
		print "To   Folder $t_fold does not exist\n" unless($silent);
		print "Creating folder [$t_fold]\n" unless($silent);
		unless ($dry){
			unless ($to->create($t_fold)){
				warn "Couldn't create [$t_fold]",
				$to->LastError,"\n";
				$error++;
				next FOLDER;
			}
			$to->setacl($t_fold, $user2, "lrswipcda"); # full
			$to->setacl($t_fold, $owner, "lrs"); # read-only
			$to->setacl($t_fold, "anyone", ""); # none
		}else{
			next FOLDER;
		}
	}
    
	unless ($to->select($t_fold)) { 
		warn 
		"To   Folder $t_fold : Could not select ",
		$to->LastError, "\n";
		$error++;
		next FOLDER;
	}
	
	if ($expunge){
		print "Expunging $f_fold and $t_fold\n" unless($silent);
		unless($dry) { $from->expunge() };
		#unless($dry) { $to->expunge() };
	}
	
	if ($subscribe and exists $fs_folders{$f_fold}) {
		print "Subscribing to folder $t_fold on destination server\n" unless($silent);
		unless($dry) { $to->subscribe($t_fold) };
	}
	
	if (0 and $syncacls) {
	  my $hash = $from->getacl($f_fold)
	    or warn "Could not getacl for $f_fold: $@\n";
	  foreach my $user (keys(%$hash)) {
	    my $acl = $hash->{$user};
	    print "acl $user : " . $acl . "\n" unless($silent);
	    unless ($dry) {
	      print "settinga acl $t_fold $user $acl\n" unless($silent);
	      $to->setacl($t_fold, $user, $acl)
		or warn "Could not set acl: $@\n";
	    }
	  }
	}
	
	next FOLDER if ($justfolders);

	my @f_msgs = $minage ? $from->before(time - 86400 * $minage) : $from->search("ALL");
	$debug and print "LIST FROM : @f_msgs\n";
	# internal dates on "TO" are after the ones on "FROM"
	# normally...
	my @t_msgs = $minage ? $to->before(time - 86400 * $minage) : $to->search("ALL");
	$debug and print "LIST TO   : @t_msgs\n";

	my %f_hash = ();
	my %t_hash = ();
	
	# No history
	$from->Clear(1);
	$to->Clear(1);

	
	print "From Buffer I/O : ", $from->Buffer(), "\n" unless($silent);
	print "To   Buffer I/O : ", $to->Buffer(), "\n" unless($silent);
#	$from->Buffer(4096*64);
#	$to->Buffer(4096*64);
#	print "From Buffer I/O : ", $from->Buffer(), "\n" unless($silent);
#	print "To   Buffer I/O : ", $to->Buffer(), "\n" unless($silent);

	print "++++ From Parse 1 ++++\n" unless($silent);
	
	my $f_heads = $from->parse_headers([@f_msgs],"ALL") if (@f_msgs) ;
	print "Time headers: ", timenext(), " s\n" unless($silent);
	my $f_size  = $from->fetch_hash("RFC822.SIZE") if (@f_msgs);
	print "Time sizes  : ", timenext(), " s\n" unless($silent);
	#my $f_flags = $from->flags(@f_msgs) ;
	#print "Time flags  : ", timenext(), " s\n" unless($silent);
	use Data::Dumper;
	#print Data::Dumper->Dump([$f_heads]);
	#print Data::Dumper->Dump([$f_flags]);
	
	#exit;
	foreach my $m (@f_msgs) {
	  parse_header_msg1($m, $f_heads, $f_size, "F", \%f_hash);
	}
	print "Time headers: ", timenext(), " s\n" unless($silent);
	
	print "\n++++ To   Parse 1 ++++\n" unless($silent);
	my $t_heads =   $to->parse_headers([@t_msgs],"ALL") if (@t_msgs);
	print "Time headers: ", timenext(), " s\n" unless($silent);
	my $t_size  =   $to->fetch_hash("RFC822.SIZE") if (@t_msgs);
	print "Time sizes  : ", timenext(), " s\n" unless($silent);
	#my $t_flags =   $to->flags(@t_msgs) ;
	#print "Time flags  : ", timenext(), " s\n" unless($silent);
	
	foreach my $m (@t_msgs) {
	  parse_header_msg1($m, $t_heads, $t_size, "T", \%t_hash);
	}
	print "Time headers: ", timenext(), " s\n" unless($silent);
	#exit;

	print "\n++++ Verifying ++++\n" unless($silent);
	# messages in "from" that are not good in "to"
	
	my @f_hash_keys_sorted_by_uid 
	  = sort {$f_hash{$a}{'m'} <=> $f_hash{$b}{'m'}} keys(%f_hash);
	
	#print map { $f_hash{$_}{'m'} . " "} @f_hash_keys_sorted_by_uid;
	
	MESS: foreach my $m_id (@f_hash_keys_sorted_by_uid) {
		my $f_size = $f_hash{$m_id}{'s'};
		my $f_msg = $f_hash{$m_id}{'m'};
		# print ".";
		if (defined $maxsize and $f_size > $maxsize) {
			print "+ Skipping msg #$f_msg:$f_size in folder $f_fold (exceeds maxsize limit $maxsize bytes)\n" unless($silent);
			$mess_size_total_skipped += $f_msg;
			next MESS;
		}
		$debug and print "+ key     $m_id #$f_msg\n";
		unless (exists($t_hash{$m_id})) {
			print "+ NO msg #$f_msg [$m_id] in $t_fold\n" unless($silent);
			# copy
			print "+ Copying msg #$f_msg:$f_size to folder $t_fold\n" unless($silent);
			my $string = $from->message_string($f_msg);
			while (my $regexmess = shift(@regexmess)) {
				$debug and print "eval \$string =~ $regexmess\n";
				eval("\$string =~ $regexmess");
				
			}
			$debug and print "F message content begin next line\n",
			  $string,
			    "F message content ended on previous line\n";
			my $d = "";
			if ($syncinternaldates) {
				$d = $from->internaldate($f_msg);
				$d = "\"$d\"";
				$debug and print "internal date from 1: [$d]\n";
			}
			
			my $flags_f = join(" ", @{$from->flags($f_msg)});
			# RFC 2060 : This flag can not be altered by the client
			$flags_f =~ s@\\Recent@@g;
		
			if ($skipunread)
			{
				my $unread = 1;
				for my $k ($flags_f) {
					if ($k eq "\\Seen") {
						$unread = 0;
					}
				}
				if ($unread) {
					print "Copy aborted for msg #$f_msg:$f_size in folder $f_fold (message is unread)\n" unless($silent);
					$mess_skipped += 1;
					$mess_size_total_skipped += $f_msg;
					next MESS;
				}
			}

			my $new_id;
			print "flags from : [$flags_f][$d]\n" unless($silent);

			unless ($dry) {
				unless($new_id = $to->append_string($t_fold,$string, $flags_f, $d)){
					warn "Couldn't append msg #$f_msg (Subject:[".$from->subject($f_msg)."]) to folder $t_fold: ",
					  $to->LastError, "\n";
					$error++;
					$mess_size_total_error += $f_size;
					next MESS;
					
				}else{
						# good
					# $new_id is an id if the IMAP server has the 
					# UIDPLUS capability else just a ref
					print "COPIED msg id [$f_msg] to folder $t_fold msg id [$new_id]\n" unless($silent);
					$mess_size_total_trans += $f_size;
					$mess_trans += 1;
					$mess_count += 1;
				}
			}
			next MESS;
		}else{
			$debug and print "Message id [$m_id] found in t:$t_fold\n";
			$mess_size_total_skipped += $f_size;
			$mess_skipped += 1;
		}
		
		$fast and next MESS;
		#$debug and print "MESSAGE $m_id\n"; 
		my $t_size = $t_hash{$m_id}{'s'};
		my $t_msg  = $t_hash{$m_id}{'m'};

		$debug and print "Setting flags\n"; 
		my (@flags_f,@flags_t);
		@flags_f = @{$from->flags($f_msg)};
		# No flag \Recent here, no ?
		
		$to->store($t_msg,
			   "+FLAGS (" . join(" ", @flags_f) . ")"
			  ) unless ($dry) ;
		@flags_t = @{$to->flags($t_msg)};
		$debug and print 
		  "flags from : @flags_f\n",
		  "flags to   : @flags_t\n";
		

		$debug and do {
			print "Looking dates\n" unless($silent); 
			my $d_f = $from->internaldate($f_msg);
			my $d_t = $to->internaldate($t_msg);
			print 
			  "idate from : $d_f\n",
			    "idate to   : $d_t\n" unless($silent);
			#unless ($d_f eq $d_t) {
			#	print "!!! Dates differ !!!\n" unless($silent);
			#}
		};
		unless ($f_size == $t_size) {
			# Bad size
			print 
			"Message $m_id SZ_BAD  f:$f_msg:$f_size t:$t_msg:$t_size\n" unless($silent);
			# delete in to and recopy ?
			# NO recopy CODE HERE. to be written if needed.
			$error++;
			if ($opt_G){
				print "Deleting msg f:#$t_msg in folder $t_fold\n" unless($silent);
				$to->delete_message($t_msg) unless ($dry);
			}
		}else {
	    		# Good 
			$debug and print
			"Message $m_id SZ_GOOD f:$f_msg:$f_size t:$t_msg:$t_size\n";
			if($delete) {
				print "Deleting msg #$f_msg in folder $f_fold\n" unless($silent);
				$from->delete_message($f_msg) unless ($dry);
				$from->expunge() if ($expunge and not $dry);
			}
		}
	}
	print "Folder copied: $f_fold - Time : ", timenext(), " s - No msgs: $mess_count\n";
}

$timeend = time();

$timediff = $timeend - $timestart;

stats();

exit(1) if($error);

sub stats {
	print "++++ Statistics ++++\n";
	print "Time                   : $timediff sec\n";
	print "Messages transfered    : $mess_trans\n";
	print "Messages skipped       : $mess_skipped\n";
	print "Total bytes transfered : $mess_size_total_trans\n";
	print "Total bytes skipped    : $mess_size_total_skipped\n";
	print "Total bytes error      : $mess_size_total_error\n";
	print "Detected $error errors\n";
}


sub get_options
{
	my $numopt = scalar(@ARGV);
        my $opt_ret = GetOptions(
                                   "debug!"       => \$debug,
                                   "debugimap!"   => \$debugimap,
                                   "host1=s"     => \$host1,
                                   "host2=s"     => \$host2,
                                   "port1=i"     => \$port1,
                                   "port2=i"     => \$port2,
                                   "user1=s"     => \$user1,
                                   "user2=s"     => \$user2,
                                   "password1=s" => \$password1,
                                   "password2=s" => \$password2,
				   "owner=s"     => \$owner,
                                   "passfile1=s" => \$passfile1,
                                   "passfile2=s" => \$passfile2,
				   "authmd5!"    => \$authmd5,
                                   "sep1=s"      => \$sep1,
                                   "sep2=s"      => \$sep2,
				   "namespace=s" => \$namespace,
				   "folder=s"    => \@folder,
				   "include=s"   => \$include,
				   "exclude=s"   => \$exclude,
				   "prefix2=s"   => \$prefix2,
				   "regextrans2=s" => \$regextrans2,
				   "regexmess=s" => \@regexmess,
                                   "delete!"     => \$delete,
                                   "syncinternaldates!" => \$syncinternaldates,
                                   "syncacls!"   => \$syncacls,
				   "maxsize=i"   => \$maxsize,
				   "minage=i"    => \$minage,
				   "foldersizes!"   => \$foldersizes,
                                   "dry!"        => \$dry,
				   "silent!"     => \$silent,
                                   "expunge!"    => \$expunge,
                                   "subscribed!" => \$subscribed,
                                   "subscribe!"  => \$subscribe,
                                   "justconnect!"=> \$justconnect,
                                   "justfolders!"=> \$justfolders,
				   "fast!"       => \$fast,
				   "skipunread!" => \$skipunread,
				   "prefixowner!"=> \$prefixowner,
                                   "version"     => \$version,
                                   "help"        => \$help,
                                   "timeout=i"   => \$timeout,
				   "skipheader=s" => \$skipheader,
				   "skipsize!"   => \$skipsize,
                                  );

        $debug and print "get options: [$opt_ret]\n";

	# just the version
        print "$VERSION\n" and exit if ($version) ;

	# exit with --help option or no option at all
        usage() and exit if ($help or ! $numopt) ;

	# don't go on if options are not all known.
        exit(EX_USAGE()) unless ($opt_ret) ;
	
	
}


sub parse_header_msg1 {
	my ($m_uid, $s_heads, $s_size, $s, $s_hash) = @_;
	
	my $head = $s_heads->{$m_uid};
	my $headnum =  scalar(keys(%$head));
	$debug and print "Head NUM:", $headnum, "\n";
	return unless($headnum);
	my $headstr;
	
	foreach my $h (sort keys(%$head)){
		foreach my $val (sort @{$head->{$h}}) {
			# no 8-bit data in headers !
			$val =~ s/[\x80-\xff]/X/g;
			# remove the first blanks (dbmail bug ?)
			$val =~ s/^\s+//;
			# show stuff in debug mode
			$debug and print "${s}H $h:", $val, "\n";
			if ($skipheader and $h =~ m/$skipheader/) {
				$debug and print "Skipping header $h\n";
		      next;
			}
			$headstr .= "$h:". $val;
		}
	}
	return unless ($headstr);
	my $size = $s_size->{$m_uid}->{"RFC822.SIZE"};
	return unless ($size);
	my $m_md5 = md5_base64($headstr);
	
	$debug and print "$s msg $m_uid:$m_md5:$size\n";
	$size = 0 if ($skipsize);
	$s_hash->{"$m_md5:$size"}{'5'} = "$m_md5:$size";
	$s_hash->{"$m_md5:$size"}{'s'} = $size;
	$s_hash->{"$m_md5:$size"}{'m'} = $m_uid;
}

sub parse_header_msg {

	my ($m, $imap, $s, $s_hash) = @_;
	$debug and print "-" x 50, "\nMSG $m\n";
	my $head = $imap->parse_headers($m,"ALL");
	my $headstr;
	$debug and print "Head NUM:", scalar(keys(%$head)), "\n";
	# no header -> return
	return unless(scalar(keys(%$head)));	    
	foreach my $h (sort keys(%$head)){
		foreach my $val (sort @{$head->{$h}}) {
			# no 8-bit data in headers !
			$val =~ s/[\x80-\xff]/X/g;
			# remove the first blanks (dbmail bug ?)
			$val =~ s/^\s+//;
			# show stuff in debug mode
			$debug and print "${s}H $h:", $val, "\n";
			if ($skipheader and $h =~ m/$skipheader/) {
				$debug and print "Skipping header $h\n";
				next;
			}
			$headstr .= "$h:". $val;
		}
	}
	my $m_md5 = md5_base64($headstr);
	my $size = $imap->size($m);
	$debug and print "$s msg $m:$m_md5:$size\n";
	$size = 0 if ($skipsize);
	$s_hash->{"$m_md5:$size"}{'5'} = "$m_md5:$size";
	$s_hash->{"$m_md5:$size"}{'s'} = $size;
	$s_hash->{"$m_md5:$size"}{'m'} = $m;
}

sub  firstline {
        # extract the first line of a file (without \n)

        my($file) = @_;
        my $line  = "";
        
        open FILE, $file or die("$! $file");
        chomp($line = <FILE>);
        close FILE;
        $line = ($line) ? $line : "!EMPTY! $file";
        return $line;   
}

sub usage {
        print <<EOF;

usage: $0 [options]

Several options are mandatory. 

--host1       <string> : "from" imap server. Mandatory.
--port1       <int>    : port to connect. Default is 143.
--user1       <string> : user to login.   Mandatory.
--password1   <string> : password for the user1. Dangerous, use --passfile1
--passfile1   <string> : password file for the user1. Contains the password.
--host2       <string> : "destination" imap server. Mandatory.
--port2       <int>    : port to connect. Default is 143.
--user2       <string> : user to login.   Mandatory.
--password2   <string> : password for the user2. Dangerous, use --passfile2
--passfile2   <string> : password file for the user2. Contains the password.
--noauthmd5            : don't use MD5 authentification
--folder      <string> : sync only this folder.
--folder      <string> : and this one.
--folder      <string> : and this one, etc.
--include     <regex>  : only sync folders matching this regular expression
                         (only effective if neither --folder nor --subscribed
			  is specified)
--exclude     <regex>  : skip folders matching this regular expression
                         (only effective if neither --folder nor --subscribed
			  is specified)
--prefix2     <string> : add prefix to all destination folders 
                         (usually INBOX. for cyrus imap servers)
--regextrans2 <regex>  : Apply the whole regex to each destination folders.
--regexmess   <regex>  : Apply the whole regex to each message before transfer.
                         Exemple : 's/\\000/ /g' # to replace null by space.
--regexmess   <regex>  : and this one.
--regexmess   <regex>  : and this one, etc.
--sep1        <string> : separator in case namespace is not supported.
--sep2        <string> : idem.
--delete               : delete messages in source imap server after
                         a successful transfert. Useful in case you
                         want to migrate from one server to another one.
			 With imap, delete tags messages as deleted, they
			 are not really deleted. See expunge.
--expunge              : expunge messages on source account.
                         expunge really deletes messages marked deleted.
                         expunge is made at the begining on the 
                         source server only. newly transfered messages
                         are expunged if option --expunge is given.
                         no expunge is done on destination account but
                         it will change in future releases.
--syncinternaldates    : set the internal dates on host2 same as host1
--maxsize     <int>    : skip messages larger than <int> bytes
--minage      <int>    : skip messages older than <int> days.
                         final stats (skipped) don't count older messages
--skipheader  <regex>  : Don't take into account header keyword 
                         matching <string> ex: --skipheader 'X.*'
--skipsize             : Don't take message size into account.
--dry                  : do nothing, just print what would be done.
--subscribed           : transfer only subscribed folders.
--subscribe            : subscribe to the folders transfered on the 
                         "destination" server that are subscribed
                         on the "source" server.
--(no)foldersizes      : Calculate the size of each "From" folder in bytes
                         and message counts. Meant to be used with
                         --justconnect. Turned on by default.
--nosyncacls           : Don't synchronizes acls.
--debug                : debug mode.
--debugimap            : imap debug mode.
--version              : print sotfware version.
--justconnect          : just connect to both servers and print useful 
                         information.
--justfolders          : just do things about folders (ignore messages).
--fast                 : be faster.
--timeout     <int>    : imap connect timeout.
--help                 : print this.

Example: to synchronise imap account "foo" on "imap.truc.org"
                     to imap account "bar" on "imap.trac.org"

$0 \\
   --host1 imap.troc.org --user1 foo --passfile1 /etc/secret1 \\
   --host2 imap.trac.org --user2 bar --passfile2 /etc/secret2


 Mail::IMAPClient version is $Mail::IMAPClient::VERSION
$rcs
      imapsync copyleft is the GNU General Public License.
      See http://www.gnu.org/copyleft/gpl.html
EOF
}
